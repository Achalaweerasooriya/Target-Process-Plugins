// Generated by TinyPG v1.3 available at www.codeproject.com

namespace Tp.SourceControl.Comments.DSL
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.ANY_TEXT, TokenType.ANY_SYMBOL, TokenType.IdKeyword1, TokenType.IdKeyword2, TokenType.TimeKeyword, TokenType.CommentKeyword1, TokenType.CommentKeyword2, TokenType.CommentKeyword3, TokenType.CommentKeyword4, TokenType.StatusKeyword1, TokenType.StatusKeyword2);
            while (tok.Type == TokenType.ANY_TEXT
                || tok.Type == TokenType.ANY_SYMBOL
                || tok.Type == TokenType.IdKeyword1
                || tok.Type == TokenType.IdKeyword2
                || tok.Type == TokenType.TimeKeyword
                || tok.Type == TokenType.CommentKeyword1
                || tok.Type == TokenType.CommentKeyword2
                || tok.Type == TokenType.CommentKeyword3
                || tok.Type == TokenType.CommentKeyword4
                || tok.Type == TokenType.StatusKeyword1
                || tok.Type == TokenType.StatusKeyword2)
            {
                ParseActionNode(node);
            tok = scanner.LookAhead(TokenType.ANY_TEXT, TokenType.ANY_SYMBOL, TokenType.IdKeyword1, TokenType.IdKeyword2, TokenType.TimeKeyword, TokenType.CommentKeyword1, TokenType.CommentKeyword2, TokenType.CommentKeyword3, TokenType.CommentKeyword4, TokenType.StatusKeyword1, TokenType.StatusKeyword2);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseActionNode(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ActionNode), "ActionNode");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.ANY_TEXT);
            while (tok.Type == TokenType.ANY_TEXT)
            {
                tok = scanner.Scan(TokenType.ANY_TEXT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ANY_TEXT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANY_TEXT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.ANY_TEXT);
            }

            
            tok = scanner.LookAhead(TokenType.ANY_SYMBOL, TokenType.IdKeyword1, TokenType.IdKeyword2);
            while (tok.Type == TokenType.ANY_SYMBOL
                || tok.Type == TokenType.IdKeyword1
                || tok.Type == TokenType.IdKeyword2)
            {

                
                ParseEntityIdClause(node);

                
                tok = scanner.LookAhead(TokenType.COMMA);
                while (tok.Type == TokenType.COMMA)
                {
                    tok = scanner.Scan(TokenType.COMMA);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMMA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                tok = scanner.LookAhead(TokenType.COMMA);
                }
            tok = scanner.LookAhead(TokenType.ANY_SYMBOL, TokenType.IdKeyword1, TokenType.IdKeyword2);
            }

            
            tok = scanner.LookAhead(TokenType.TimeKeyword, TokenType.CommentKeyword1, TokenType.CommentKeyword2, TokenType.CommentKeyword3, TokenType.CommentKeyword4, TokenType.StatusKeyword1, TokenType.StatusKeyword2, TokenType.ANY_TEXT);
            while (tok.Type == TokenType.TimeKeyword
                || tok.Type == TokenType.CommentKeyword1
                || tok.Type == TokenType.CommentKeyword2
                || tok.Type == TokenType.CommentKeyword3
                || tok.Type == TokenType.CommentKeyword4
                || tok.Type == TokenType.StatusKeyword1
                || tok.Type == TokenType.StatusKeyword2
                || tok.Type == TokenType.ANY_TEXT)
            {
                tok = scanner.LookAhead(TokenType.TimeKeyword, TokenType.CommentKeyword1, TokenType.CommentKeyword2, TokenType.CommentKeyword3, TokenType.CommentKeyword4, TokenType.StatusKeyword1, TokenType.StatusKeyword2, TokenType.ANY_TEXT);
                switch (tok.Type)
                {
                    case TokenType.TimeKeyword:
                        ParsePostTimeClause(node);
                        break;
                    case TokenType.CommentKeyword1:
                    case TokenType.CommentKeyword2:
                    case TokenType.CommentKeyword3:
                    case TokenType.CommentKeyword4:
                        ParsePostCommentClause(node);
                        break;
                    case TokenType.StatusKeyword1:
                    case TokenType.StatusKeyword2:
                        ParseChangeStatusClause(node);
                        break;
                    case TokenType.ANY_TEXT:
                        tok = scanner.Scan(TokenType.ANY_TEXT);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.ANY_TEXT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANY_TEXT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            tok = scanner.LookAhead(TokenType.TimeKeyword, TokenType.CommentKeyword1, TokenType.CommentKeyword2, TokenType.CommentKeyword3, TokenType.CommentKeyword4, TokenType.StatusKeyword1, TokenType.StatusKeyword2, TokenType.ANY_TEXT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseEntityIdClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.EntityIdClause), "EntityIdClause");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.ANY_SYMBOL);
            while (tok.Type == TokenType.ANY_SYMBOL)
            {
                tok = scanner.Scan(TokenType.ANY_SYMBOL);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ANY_SYMBOL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANY_SYMBOL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.ANY_SYMBOL);
            }

            
            tok = scanner.LookAhead(TokenType.IdKeyword1, TokenType.IdKeyword2);
            switch (tok.Type)
            {
                case TokenType.IdKeyword1:
                    tok = scanner.Scan(TokenType.IdKeyword1);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IdKeyword1) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IdKeyword1.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IdKeyword2:
                    tok = scanner.Scan(TokenType.IdKeyword2);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IdKeyword2) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IdKeyword2.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.NUMBER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NUMBER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.ANY_SYMBOL);
            while (tok.Type == TokenType.ANY_SYMBOL)
            {
                tok = scanner.Scan(TokenType.ANY_SYMBOL);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ANY_SYMBOL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANY_SYMBOL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.ANY_SYMBOL);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePostTimeClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PostTimeClause), "PostTimeClause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.TimeKeyword);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TimeKeyword) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TimeKeyword.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.DECIMAL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DECIMAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.Delimiter);
            if (tok.Type == TokenType.Delimiter)
            {

                
                tok = scanner.Scan(TokenType.Delimiter);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Delimiter) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Delimiter.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.Scan(TokenType.DECIMAL);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DECIMAL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseChangeStatusClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ChangeStatusClause), "ChangeStatusClause");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.StatusKeyword1, TokenType.StatusKeyword2);
            switch (tok.Type)
            {
                case TokenType.StatusKeyword1:
                    tok = scanner.Scan(TokenType.StatusKeyword1);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.StatusKeyword1) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StatusKeyword1.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.StatusKeyword2:
                    tok = scanner.Scan(TokenType.StatusKeyword2);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.StatusKeyword2) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StatusKeyword2.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.Scan(TokenType.ANY_TEXT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ANY_TEXT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANY_TEXT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePostCommentClause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PostCommentClause), "PostCommentClause");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.CommentKeyword1, TokenType.CommentKeyword2, TokenType.CommentKeyword3, TokenType.CommentKeyword4);
            switch (tok.Type)
            {
                case TokenType.CommentKeyword1:
                    tok = scanner.Scan(TokenType.CommentKeyword1);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CommentKeyword1) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CommentKeyword1.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CommentKeyword2:
                    tok = scanner.Scan(TokenType.CommentKeyword2);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CommentKeyword2) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CommentKeyword2.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CommentKeyword3:
                    tok = scanner.Scan(TokenType.CommentKeyword3);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CommentKeyword3) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CommentKeyword3.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CommentKeyword4:
                    tok = scanner.Scan(TokenType.CommentKeyword4);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CommentKeyword4) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CommentKeyword4.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.ANY_TEXT);
            while (tok.Type == TokenType.ANY_TEXT)
            {
                tok = scanner.Scan(TokenType.ANY_TEXT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ANY_TEXT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ANY_TEXT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            tok = scanner.LookAhead(TokenType.ANY_TEXT);
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
